package squidpony.squidmath;

import squidpony.annotation.Beta;

import java.io.Serializable;

import static squidpony.squidmath.Noise.HastyPointHash.perm_x;
import static squidpony.squidmath.Noise.HastyPointHash.perm_y;
import static squidpony.squidmath.Noise.HastyPointHash.perm_z;
import static squidpony.squidmath.Noise.HastyPointHash.perm_w;
import static squidpony.squidmath.Noise.fastFloor;

/**
 * Another experimental noise class. Extends PerlinNoise and should have similar quality, but can be faster and has less
 * periodic results. This is still considered experimental because the exact output may change in future versions, along
 * with the scale (potentially) and the parameters it takes. In general, {@link #noise(double, double)} and
 * {@link #noise(double, double, double)} should have similar appearance to {@link PerlinNoise#noise(double, double)},
 * {@link PerlinNoise#noise(double, double, double)}, and {@link PerlinNoise#noise(double, double, double, double)}, but
 * are not forced to a zoomed-in scale like PerlinNoise makes its results, have a lower chance of forming shapes with
 * multiple octaves that appear "non-natural" (such as long straight lines, axis-aligned shapes, and hard angles), and
 * the 3D and 4D noise variants tend to be faster due to a more efficient method for hashing points. WhirlingNoise is
 * preferred to other related {@link Noise.Noise3D} or {@link Noise.Noise4D} implementations for most world map
 * generation (usually using {@link squidpony.squidgrid.mapping.WorldMapGenerator}) because it is less likely to produce
 * artificial-seeming shapes, which are out-of-place in a world map.
 * <br>
 * Created by Tommy Ettinger on 12/14/2016. The technique for point hashing here is based closely on
 * <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.3594&rep=rep1&type=pdf">this paper</a>,
 * with credit to Andrew Kensler, Aaron Knoll and Peter Shirley.
 */
@Beta
public class WhirlingNoise extends PerlinNoise implements Noise.Noise2D, Noise.Noise3D, Noise.Noise4D, Serializable {

    private static final long serialVersionUID = 5L;
    public long seed;
    public static final WhirlingNoise instance = new WhirlingNoise();
    public WhirlingNoise()
    {
        this(123456789);
    }
    public WhirlingNoise(long seed) {
        this.seed = seed;
//        System.out.println("{");
//        for (int i = 0; i < grad3f.length; i++) {
//            System.out.printf("{% 2.15ff, % 2.15ff, % 2.15ff},\n", grad3f[i][0], grad3f[i][1], grad3f[i][2]);
//        }
//        System.out.println("}");
    }

    protected static final float
            //root2 = 1.4142135f,
            root3 = 1.7320508f,
            F2f = 0.5f * (root3 - 1f),
            G2f = (3f - root3) * 0.16666667f,
            F3f = 0.33333334f,
            G3f = 0.16666667f;
    /*
            root5 = 2.236068f,
            F4f = (root5 - 1f) * 0.25f,
            G4f = (5f - root5) * 0.05f,
            unit1_4f =  0.70710678118f, unit1_8f = 0.38268343236f, unit3_8f = 0.92387953251f;
    */
    /*
    protected static final float[][] grad2f = {
            {1f, 0f}, {-1f, 0f}, {0f, 1f}, {0f, -1f},
            {unit3_8f, unit1_8f}, {unit3_8f, -unit1_8f}, {-unit3_8f, unit1_8f}, {-unit3_8f, -unit1_8f},
            {unit1_4f, unit1_4f}, {unit1_4f, -unit1_4f}, {-unit1_4f, unit1_4f}, {-unit1_4f, -unit1_4f},
            {unit1_8f, unit3_8f}, {unit1_8f, -unit3_8f}, {-unit1_8f, unit3_8f}, {-unit1_8f, -unit3_8f}};
    */
    protected static final float[][] phiGrad2f = {

            {0.8150192046878179f, 0.5794339444578966f},
            {0.3285126080199264f, 0.9444995851624003f},
            {-0.27953103565117526f, 0.9601366569961702f},
            {-0.7841589327438924f, 0.6205600439908774f},
            {-0.9986781437763752f, 0.05140005003279401f},
            {-0.8437248002155627f, -0.5367759881935933f},
            {-0.37662568751777636f, -0.9263655280189145f},
            {0.22981046360408072f, -0.9732354035987786f},
            {0.7512255700688496f, -0.6600455612112939f},
            {0.9947160697132525f, -0.10266421311352707f},
            {0.8701998299869244f, 0.49269895056791824f},
            {0.4237430769975827f, 0.9057824267983017f},
            {-0.17948233877384698f, 0.983761195650789f},
            {-0.7163061830035246f, 0.6977861077657832f},
            {-0.9881242523951498f, 0.15365696153616482f},
            {-0.894374301636155f, -0.44731935859387983f},
            {-0.4697402116302938f, -0.8828046973014625f},
            {0.12867971425053623f, -0.991686205984736f},
            {0.6794930883661505f, -0.7336819085016549f},
            {0.9789201186915606f, -0.20424348513698282f},
            {0.9161843048116499f, 0.4007571828636311f},
            {0.5144954882185442f, 0.857493086037877f},
            {-0.07753689756495279f, 0.9969894831521554f},
            {-0.6408836093932414f, 0.7676380652437f},
            {-0.9671280016853234f, 0.25429004769387453f},
            {-0.9355721801365401f, -0.3531355203807194f},
            {-0.5578905866805359f, -0.8299145096293036f},
            {0.026189095618157535f, -0.9996570068131884f},
            {0.6005798184449439f, -0.7995648076776756f},
            {0.9527790763429471f, -0.30366434048646623f},
            {0.9524866716435015f, 0.30458026912701447f},
            {0.5998107828543199f, 0.8001418779014681f},
            {0.025227942766709196f, 0.9996817248023291f},
            {-0.5586882671550536f, 0.8293777306772129f},
            {-0.9359112770969633f, 0.35223583208232967f},
            {-0.9668830622808007f, -0.25521979522462845f},
            {-0.6401452517954772f, -0.7682539011314586f},
            {-0.07657828572526153f, -0.997063571772322f},
            {0.5153197047391562f, -0.8569980174466851f},
            {0.9165691975581982f, -0.39987611342454643f},
            {0.9787232921313124f, 0.20518459357282604f},
            {0.6787873607664123f, 0.7343348819603821f},
            {0.12772617771665648f, 0.9918094693669208f},
            {-0.4705887852055238f, 0.8823526478901672f},
            {-0.8948039726230813f, 0.44645923730834813f},
            {-0.987976059032004f, -0.1546069428570078f},
            {-0.7156349511426562f, -0.6984744925214149f},
            {-0.17853639842218227f, -0.9839333079220541f},
            {0.42461376424291053f, -0.9053745916555567f},
            {0.8706731432876941f, -0.49186205134928496f},
            {0.9946169013278476f, 0.10362055584193075f},
            {0.7505906084908771f, 0.6607675373724824f},
            {0.22887462022891217f, 0.9734559097437702f},
            {-0.37751618658649483f, 0.926002985343563f},
            {-0.8442405045259113f, 0.53596452356274f},
            {-0.998628262541406f, -0.052360225873583494f},
            {-0.7835619201046374f, -0.6213137028602651f},
            {-0.27860776335327647f, -0.9604049740600497f},
            {0.32942056468855896f, -0.9441832934130274f},
            {0.815575936633839f, -0.5786500596939711f},
            {0.9999995377871086f, 9.614705243498993E-4f},
            {0.8144617193170308f, 0.5802172935781439f},
            {0.32760434766577023f, 0.9448150037920043f},
            {-0.2804540495433758f, 0.9598674523572105f},
            {-0.7847552204864104f, 0.6198058114597872f},
            {-0.9987271018075193f, 0.05043982667647658f},
            {-0.8432083159442574f, -0.5375869566148805f},
            {-0.37573484028656684f, -0.9267272143380857f},
            {0.23074609453653327f, -0.9730139977698868f},
            {0.7518598371945376f, -0.6593229748869694f},
            {0.9948143185574757f, -0.10170777547968135f},
            {0.8697257122509974f, 0.4935353943229353f},
            {0.4228719980332324f, 0.9061894246124161f},
            {-0.18042811320741017f, 0.9835881739653105f},
            {-0.7169767526924914f, 0.69709707795868f},
            {-0.9882715323107604f, 0.15270683817086136f},
            {-0.8939438038665631f, -0.44817906636586646f},
            {-0.4688912038150978f, -0.883255930625336f},
            {0.1296331318295739f, -0.9915620258622535f},
            {0.6801981878249586f, -0.7330282568084551f},
            {0.9791160403128117f, -0.20330218789319596f},
            {0.9157985651207083f, 0.40163788183244326f},
            {0.5136707960850377f, 0.8579873619403514f},
            {-0.07849543772753681f, 0.9969144728892054f},
            {-0.6416213745416761f, 0.7670215197315198f},
            {-0.9673720470517861f, 0.2533600650908442f},
            {-0.9352322183090706f, -0.3540348822315325f},
            {-0.5570923904775789f, -0.8304505213870221f},
            {0.0271502242597271f, -0.9996313647153368f},
            {0.6013482988440962f, -0.7989869983155617f},
            {0.9530706002688482f, -0.30274813113077575f},
            {0.9521933864408199f, 0.3054959162057056f},
            {0.5990411927831463f, 0.8007182084534767f},
            {0.02426676659390367f, 0.9997055186599086f},
            {-0.5594854311637297f, 0.8288401850269662f},
            {-0.9362495088768715f, 0.3513358181680552f},
            {-0.9666372290646448f, -0.2561493068236286f},
            {-0.639406302430932f, -0.7688690268255078f},
            {-0.07561960309462855f, -0.9971367386812156f},
            {0.5161434448849468f, -0.8565021566244302f},
            {0.9169532430045485f, -0.39899467432967256f},
            {0.9785255608140186f, 0.20612551233074072f},
            {0.6780810056781368f, 0.7349871765810113f},
            {0.1267725231094102f, 0.9919318158948598f},
            {-0.4714369237563429f, 0.8818997828093372f},
            {-0.8952328164301424f, 0.4455987033043912f},
            {-0.9878269523583152f, -0.15555678125521535f},
            {-0.7149630577303816f, -0.6991622315892235f},
            {-0.1775902930268572f, -0.9841045106200027f},
            {0.42548405896433017f, -0.9049659195611945f},
            {0.8711456517157633f, -0.4910246974406867f},
            {0.9945168134929346f, 0.10457680278082451f},
            {0.7499549530475861f, 0.6614889027031315f},
            {0.2279385652761324f, 0.973675516001023f},
            {-0.37840633666951456f, 0.9256395866471777f},
            {-0.8447554283985693f, 0.535152563472464f},
            {-0.9985774581487236f, -0.05332035331122841f},
            {-0.782964183120542f, -0.6220667873712457f},
            {-0.27768423350317883f, -0.9606724033008089f},
            {0.3303282168323275f, -0.9438661288362745f},
            {0.8161319146404362f, -0.5778656400110114f},
            {0.9999981511488616f, 0.0019229401598916565f},
            {0.8139034810368312f, 0.5810001063305656f},
            {0.3266957844657079f, 0.945129549010259f},
            {-0.281376804176623f, 0.9595973603920294f},
            {-0.7853507827809703f, 0.6190510059642236f},
            {-0.9987751365895806f, 0.04947955669228112f},
            {-0.8426910521894434f, -0.538397428076926f},
            {-0.3748436457163809f, -0.9270880439667272f},
            {0.23168151216134933f, -0.9727916924617678f},
            {0.7524934092816089f, -0.6585997790674858f},
            {0.994911647769694f, -0.10075124382454212f},
            {0.8692507905181963f, 0.49437138184111223f},
            {0.42200052815510103f, 0.906595584721664f},
            {-0.18137372084857706f, 0.9834142430255637f},
            {-0.7176466595896562f, 0.6964074037370712f},
            {-0.9884178986426848f, 0.15175657363942827f},
            {-0.8935124797122745f, -0.4490383598295609f},
            {-0.46804176254479146f, -0.8837063474446503f},
            {0.1305864295723934f, -0.9914369291142702f},
            {0.6809026584910192f, -0.7323739274850399f},
            {0.9793110568139495f, -0.20236070271163187f},
            {0.9154119788419642f, 0.40251820951683553f},
            {0.5128456291010095f, 0.8584808446971836f},
            {-0.07945390532690727f, 0.9968385410528141f},
            {-0.6423585465587638f, 0.7664042651648753f},
            {-0.9676151981545856f, 0.2524298482752425f},
            {-0.934891391928828f, -0.35493391680336583f},
            {-0.5562936792840555f, -0.8309857654548652f},
            {0.028111327802940005f, -0.9996047985324779f},
            {0.6021162233413851f, -0.7984084503492602f},
            {0.9533612431517168f, -0.30183164190689693f},
            {0.9518992210060183f, 0.30641128087610536f},
            {0.5982710489428404f, 0.8012937988009351f},
            {0.023305567988262783f, 0.9997283883639319f},
            {-0.5602820779696569f, 0.8283018731754765f},
            {-0.9365868751635984f, 0.350435479469882f},
            {-0.9663905022641126f, -0.25707858163160174f},
            {-0.6386667619827179f, -0.7694834417572027f},
            {-0.07466085055928477f, -0.997208983811199f},
            {0.5169667078944292f, -0.8560055040294986f},
            {0.9173364407956793f, -0.3981128663938346f},
            {0.9783269249224673f, 0.2070662405409173f},
            {0.6773740237542967f, 0.7356387917605443f},
            {0.12581875131036094f, 0.9920532454554551f},
            {-0.47228462649872727f, 0.8814461024776034f},
            {-0.8956608326609128f, 0.44473775737749144f},
            {-0.9876769325119248f, -0.1565064758527096f},
            {-0.7142905033878327f, -0.6998493243334286f},
            {-0.17664402346250044f, -0.9842748035863661f},
            {0.4263539603573059f, -0.9045564108930083f},
            {0.8716173548343263f, -0.4901868896162075f},
            {0.994415806301039f, 0.1055329530462149f},
            {0.7493186043266098f, 0.6622096565363733f},
            {0.22700229961107984f, 0.9738942221675214f},
            {-0.37929613694395364f, 0.9252753322656957f},
            {-0.8452695713575256f, 0.5343401086733665f},
            {-0.998525730645293f, -0.054280431458156884f},
            {-0.7823657223441729f, -0.6228192968276437f},
            {-0.2767604469546231f, -0.9609389444712277f},
            {0.3312355636121689f, -0.943548091725339f},
            {0.8166871381936452f, -0.5770806861341607f},
            {0.999995840086541f, 0.0028844080178108454f},
            {0.8133444903632729f, 0.5817823819915036f},
            {0.325786919259646f, 0.9454432205263883f},
            {-0.28229929869789083f, 0.9593263813503092f},
            {-0.7859456190770135f, 0.6182956282019548f},
            {-0.998822248078154f, 0.04851924096791483f},
            {-0.8421730094292976f, -0.5392074018305016f},
            {-0.373952104631071f, -0.9274480165712753f},
            {0.23261671561379524f, -0.9725684878799286f},
            {0.7531262857443665f, -0.6578759744213911f},
            {0.9950080572599341f, -0.09979461903234838f},
            {0.8687750652275492f, 0.49520691234964365f},
            {0.42112866816879463f, 0.9070009067505816f},
            {-0.18231916082320707f, 0.9832394029923341f},
            {-0.7183159030757559f, 0.6957170857384928f},
            {-0.9885633512556217f, 0.15080616882029174f},
            {-0.893080329572006f, -0.44989723819063077f},
            {-0.46719188860459987f, -0.8841559473430393f},
            {0.1315396065977646f, -0.9913109158564256f},
            {0.681606499713117f, -0.7317189211362739f},
            {0.9795051680146997f, -0.20141903046260284f},
            {0.9150245463327793f, 0.40339816510302995f},
            {0.512019988029247f, 0.858973533852196f},
            {-0.08041229947705328f, 0.9967616877131729f},
            {-0.6430951247630602f, 0.7657863021143588f},
            {-0.9678574547689481f, 0.2514993981069807f},
            {-0.9345497013108786f, -0.35583262326513526f},
            {-0.5554944538383123f, -0.8315202413380417f},
            {0.02907240535928829f, -0.9995773082891715f},
            {0.6028835912268903f, -0.7978291643136192f},
            {0.9536510047228631f, -0.3009148736620934f},
            {0.9516041756110342f, 0.307326362292017f},
            {0.5975003520453519f, 0.8018686484117461f},
            {0.022344347838353967f, 0.9997503338932568f},
            {-0.5610782068363855f, 0.8277627956203795f},
            {-0.93692337564527f, 0.34953481682011633f},
            {-0.966142882107282f, -0.2580076187895127f},
            {-0.6379266311344768f, -0.7700971453585691f},
            {-0.0737020290055187f, -0.9972803070954874f},
            {0.5177894930065641f, -0.8555080601210051f},
            {0.9177187905773555f, -0.3972306904321919f},
            {0.978127384640281f, 0.20800677733372933f},
            {0.6766664156484392f, 0.7362897268966162f},
            {0.12486486320121397f, 0.9921737579364525f},
            {-0.47313189264902605f, 0.8809916073143662f},
            {-0.8960880209197166f, 0.4438764003235422f},
            {-0.9875259996315107f, -0.15745602577159645f},
            {-0.713617288736716f, -0.7005357701188843f},
            {-0.17569759060384005f, -0.9844441866637262f},
            {0.4272234676177009f, -0.9041460660295477f},
            {0.8720882522073408f, -0.48934862865031664f},
            {0.9943138798455315f, 0.1064890057542367f},
            {0.7486815629161868f, 0.6629297982059457f},
            {0.22606582409923492f, 0.9741120280410943f},
            {-0.3801855865872776f, 0.9249102225358349f},
            {-0.8457829329275041f, 0.5335271599164837f},
            {-0.9984730800789315f, -0.055240459426869205f},
            {-0.7817665383287496f, -0.6235712305338369f},
            {-0.2758364045615609f, -0.9612045973249145f},
            {0.3321426041893285f, -0.9432291823742155f},
            {0.8172416067802154f, -0.5762951987890336f},
            {0.9999926046022829f, 0.003845873209323106f},
            {0.8127847478130893f, 0.582564119837819f},
            {0.3248777528877428f, 0.9457560180504329f},
            {-0.2832215322544221f, 0.9590545154825441f},
            {-0.7865397288246715f, 0.6175396788712546f},
            {-0.9988684362296896f, 0.04755888039109703f},
            {-0.8416541881427008f, -0.5400168771268647f},
            {-0.37306021785478083f, -0.92780713181897f},
            {0.23355170402936554f, -0.9723443842307002f},
            {0.7537584659977772f, -0.6571515616177731f},
            {0.9951035469390707f, -0.09883790198744995f},
            {0.8682985368188393f, 0.4960419850761251f},
            {0.4202564188803024f, 0.90740539032447f}
    };
    /**
     * The 32 3D vertices of a rhombic triacontahedron. These were modified from values taken from Vladimir Bulatov's
     * stellation applet, which has available source but is unlicensed, and is
     * <a href="http://www.bulatov.org/polyhedra/stellation_applet/index.html">available here</a>, but the vertices are
     * mathematical constants so copyright isn't an issue.
     */
    protected static final float[][] grad3f =
            {
                    {-0.448549002408981f,  1.174316525459290f,  0.000000000000001f},
                    { 0.000000000000001f,  1.069324374198914f,  0.660878777503967f},
                    { 0.448549002408981f,  1.174316525459290f,  0.000000000000001f},
                    { 0.000000000000001f,  1.069324374198914f, -0.660878777503967f},
                    {-0.725767493247986f,  0.725767493247986f, -0.725767493247986f},
                    {-1.069324374198914f,  0.660878777503967f,  0.000000000000001f},
                    {-0.725767493247986f,  0.725767493247986f,  0.725767493247986f},
                    { 0.725767493247986f,  0.725767493247986f,  0.725767493247986f},
                    { 1.069324374198914f,  0.660878777503967f,  0.000000000000000f},
                    { 0.725767493247986f,  0.725767493247986f, -0.725767493247986f},
                    {-0.660878777503967f,  0.000000000000003f, -1.069324374198914f},
                    {-1.174316525459290f,  0.000000000000003f, -0.448549002408981f},
                    { 0.000000000000000f,  0.448549002408981f, -1.174316525459290f},
                    {-0.660878777503967f,  0.000000000000001f,  1.069324374198914f},
                    { 0.000000000000001f,  0.448549002408981f,  1.174316525459290f},
                    {-1.174316525459290f,  0.000000000000001f,  0.448549002408981f},
                    { 0.660878777503967f,  0.000000000000001f,  1.069324374198914f},
                    { 1.174316525459290f,  0.000000000000001f,  0.448549002408981f},
                    { 0.660878777503967f,  0.000000000000001f, -1.069324374198914f},
                    { 1.174316525459290f,  0.000000000000001f, -0.448549002408981f},
                    {-0.725767493247986f, -0.725767493247986f, -0.725767493247986f},
                    {-1.069324374198914f, -0.660878777503967f, -0.000000000000001f},
                    {-0.000000000000001f, -0.448549002408981f, -1.174316525459290f},
                    {-0.000000000000001f, -0.448549002408981f,  1.174316525459290f},
                    {-0.725767493247986f, -0.725767493247986f,  0.725767493247986f},
                    { 0.725767493247986f, -0.725767493247986f,  0.725767493247986f},
                    { 1.069324374198914f, -0.660878777503967f,  0.000000000000001f},
                    { 0.725767493247986f, -0.725767493247986f, -0.725767493247986f},
                    {-0.000000000000004f, -1.069324374198914f, -0.660878777503967f},
                    {-0.448549002408981f, -1.174316525459290f, -0.000000000000003f},
                    {-0.000000000000003f, -1.069324374198914f,  0.660878777503967f},
                    { 0.448549002408981f, -1.174316525459290f,  0.000000000000003f},
            };
    // these are the exact vertex positions, before scaling has been applied
//            {
//            {-0.324919696232904f,  0.850650808352036f,  0.000000000000001f },
//            { 0.000000000000001f,  0.850650808352035f,  0.525731112119131f },
//            { 0.324919696232906f,  0.850650808352036f,  0.000000000000001f },
//            { 0.000000000000001f,  0.850650808352036f, -0.525731112119131f },
//            {-0.525731112119131f,  0.525731112119132f, -0.525731112119130f },
//            {-0.850650808352035f,  0.525731112119132f,  0.000000000000001f },
//            {-0.525731112119130f,  0.525731112119131f,  0.525731112119132f },
//            { 0.525731112119132f,  0.525731112119131f,  0.525731112119131f },
//            { 0.850650808352036f,  0.525731112119132f,  0.000000000000000f },
//            { 0.525731112119132f,  0.525731112119132f, -0.525731112119131f },
//            {-0.525731112119132f,  0.000000000000002f, -0.850650808352036f },
//            {-0.850650808352036f,  0.000000000000002f, -0.324919696232905f },
//            { 0.000000000000000f,  0.324919696232906f, -0.850650808352037f },
//            {-0.525731112119131f,  0.000000000000001f,  0.850650808352037f },
//            { 0.000000000000001f,  0.324919696232905f,  0.850650808352037f },
//            {-0.850650808352037f,  0.000000000000001f,  0.324919696232905f },
//            { 0.525731112119133f,  0.000000000000001f,  0.850650808352036f },
//            { 0.850650808352037f,  0.000000000000001f,  0.324919696232905f },
//            { 0.525731112119132f,  0.000000000000001f, -0.850650808352038f },
//            { 0.850650808352038f,  0.000000000000001f, -0.324919696232906f },
//            {-0.525731112119134f, -0.525731112119130f, -0.525731112119133f },
//            {-0.850650808352038f, -0.525731112119130f, -0.000000000000001f },
//            {-0.000000000000001f, -0.324919696232905f, -0.850650808352038f },
//            {-0.000000000000001f, -0.324919696232905f,  0.850650808352038f },
//            {-0.525731112119132f, -0.525731112119131f,  0.525731112119133f },
//            { 0.525731112119133f, -0.525731112119131f,  0.525731112119134f },
//            { 0.850650808352039f, -0.525731112119130f,  0.000000000000001f },
//            { 0.525731112119132f, -0.525731112119134f, -0.525731112119133f },
//            {-0.000000000000003f, -0.850650808352038f, -0.525731112119134f },
//            {-0.324919696232908f, -0.850650808352038f, -0.000000000000002f },
//            {-0.000000000000002f, -0.850650808352042f,  0.525731112119130f },
//            { 0.324919696232902f, -0.850650808352041f,  0.000000000000002f }
//    };
    protected static final float[] grad3d =
            {
                    -0.448549002408981f,  1.174316525459290f,  0.000000000000001f,
                     0.000000000000001f,  1.069324374198914f,  0.660878777503967f,
                     0.448549002408981f,  1.174316525459290f,  0.000000000000001f,
                     0.000000000000001f,  1.069324374198914f, -0.660878777503967f,
                    -0.725767493247986f,  0.725767493247986f, -0.725767493247986f,
                    -1.069324374198914f,  0.660878777503967f,  0.000000000000001f,
                    -0.725767493247986f,  0.725767493247986f,  0.725767493247986f,
                     0.725767493247986f,  0.725767493247986f,  0.725767493247986f,
                     1.069324374198914f,  0.660878777503967f,  0.000000000000000f,
                     0.725767493247986f,  0.725767493247986f, -0.725767493247986f,
                    -0.660878777503967f,  0.000000000000003f, -1.069324374198914f,
                    -1.174316525459290f,  0.000000000000003f, -0.448549002408981f,
                     0.000000000000000f,  0.448549002408981f, -1.174316525459290f,
                    -0.660878777503967f,  0.000000000000001f,  1.069324374198914f,
                     0.000000000000001f,  0.448549002408981f,  1.174316525459290f,
                    -1.174316525459290f,  0.000000000000001f,  0.448549002408981f,
                     0.660878777503967f,  0.000000000000001f,  1.069324374198914f,
                     1.174316525459290f,  0.000000000000001f,  0.448549002408981f,
                     0.660878777503967f,  0.000000000000001f, -1.069324374198914f,
                     1.174316525459290f,  0.000000000000001f, -0.448549002408981f,
                    -0.725767493247986f, -0.725767493247986f, -0.725767493247986f,
                    -1.069324374198914f, -0.660878777503967f, -0.000000000000001f,
                    -0.000000000000001f, -0.448549002408981f, -1.174316525459290f,
                    -0.000000000000001f, -0.448549002408981f,  1.174316525459290f,
                    -0.725767493247986f, -0.725767493247986f,  0.725767493247986f,
                     0.725767493247986f, -0.725767493247986f,  0.725767493247986f,
                     1.069324374198914f, -0.660878777503967f,  0.000000000000001f,
                     0.725767493247986f, -0.725767493247986f, -0.725767493247986f,
                    -0.000000000000004f, -1.069324374198914f, -0.660878777503967f,
                    -0.448549002408981f, -1.174316525459290f, -0.000000000000003f,
                    -0.000000000000003f, -1.069324374198914f,  0.660878777503967f,
                     0.448549002408981f, -1.174316525459290f,  0.000000000000003f,
            };

    protected static final double[] grad4 =
            {
                    -0.5875167, 1.4183908, 1.4183908, 1.4183908,
                    -0.5875167, 1.4183908, 1.4183908, -1.4183908,
                    -0.5875167, 1.4183908, -1.4183908, 1.4183908,
                    -0.5875167, 1.4183908, -1.4183908, -1.4183908,
                    -0.5875167, -1.4183908, 1.4183908, 1.4183908,
                    -0.5875167, -1.4183908, 1.4183908, -1.4183908,
                    -0.5875167, -1.4183908, -1.4183908, 1.4183908,
                    -0.5875167, -1.4183908, -1.4183908, -1.4183908,
                    1.4183908, -0.5875167, 1.4183908, 1.4183908,
                    1.4183908, -0.5875167, 1.4183908, -1.4183908,
                    1.4183908, -0.5875167, -1.4183908, 1.4183908,
                    1.4183908, -0.5875167, -1.4183908, -1.4183908,
                    -1.4183908, -0.5875167, 1.4183908, 1.4183908,
                    -1.4183908, -0.5875167, 1.4183908, -1.4183908,
                    -1.4183908, -0.5875167, -1.4183908, 1.4183908,
                    -1.4183908, -0.5875167, -1.4183908, -1.4183908,
                    1.4183908, 1.4183908, -0.5875167, 1.4183908,
                    1.4183908, 1.4183908, -0.5875167, -1.4183908,
                    1.4183908, -1.4183908, -0.5875167, 1.4183908,
                    1.4183908, -1.4183908, -0.5875167, -1.4183908,
                    -1.4183908, 1.4183908, -0.5875167, 1.4183908,
                    -1.4183908, 1.4183908, -0.5875167, -1.4183908,
                    -1.4183908, -1.4183908, -0.5875167, 1.4183908,
                    -1.4183908, -1.4183908, -0.5875167, -1.4183908,
                    1.4183908, 1.4183908, 1.4183908, -0.5875167,
                    1.4183908, 1.4183908, -1.4183908, -0.5875167,
                    1.4183908, -1.4183908, 1.4183908, -0.5875167,
                    1.4183908, -1.4183908, -1.4183908, -0.5875167,
                    -1.4183908, 1.4183908, 1.4183908, -0.5875167,
                    -1.4183908, 1.4183908, -1.4183908, -0.5875167,
                    -1.4183908, -1.4183908, 1.4183908, -0.5875167,
                    -1.4183908, -1.4183908, -1.4183908, -0.5875167,
                    0.5875167, 1.4183908, 1.4183908, 1.4183908,
                    0.5875167, 1.4183908, 1.4183908, -1.4183908,
                    0.5875167, 1.4183908, -1.4183908, 1.4183908,
                    0.5875167, 1.4183908, -1.4183908, -1.4183908,
                    0.5875167, -1.4183908, 1.4183908, 1.4183908,
                    0.5875167, -1.4183908, 1.4183908, -1.4183908,
                    0.5875167, -1.4183908, -1.4183908, 1.4183908,
                    0.5875167, -1.4183908, -1.4183908, -1.4183908,
                    1.4183908, 0.5875167, 1.4183908, 1.4183908,
                    1.4183908, 0.5875167, 1.4183908, -1.4183908,
                    1.4183908, 0.5875167, -1.4183908, 1.4183908,
                    1.4183908, 0.5875167, -1.4183908, -1.4183908,
                    -1.4183908, 0.5875167, 1.4183908, 1.4183908,
                    -1.4183908, 0.5875167, 1.4183908, -1.4183908,
                    -1.4183908, 0.5875167, -1.4183908, 1.4183908,
                    -1.4183908, 0.5875167, -1.4183908, -1.4183908,
                    1.4183908, 1.4183908, 0.5875167, 1.4183908,
                    1.4183908, 1.4183908, 0.5875167, -1.4183908,
                    1.4183908, -1.4183908, 0.5875167, 1.4183908,
                    1.4183908, -1.4183908, 0.5875167, -1.4183908,
                    -1.4183908, 1.4183908, 0.5875167, 1.4183908,
                    -1.4183908, 1.4183908, 0.5875167, -1.4183908,
                    -1.4183908, -1.4183908, 0.5875167, 1.4183908,
                    -1.4183908, -1.4183908, 0.5875167, -1.4183908,
                    1.4183908, 1.4183908, 1.4183908, 0.5875167,
                    1.4183908, 1.4183908, -1.4183908, 0.5875167,
                    1.4183908, -1.4183908, 1.4183908, 0.5875167,
                    1.4183908, -1.4183908, -1.4183908, 0.5875167,
                    -1.4183908, 1.4183908, 1.4183908, 0.5875167,
                    -1.4183908, 1.4183908, -1.4183908, 0.5875167,
                    -1.4183908, -1.4183908, 1.4183908, 0.5875167,
                    -1.4183908, -1.4183908, -1.4183908, 0.5875167,
            };
//    public static void randomUnitVector4(long seed, final float[] vector)
//    {
//        double mag = 0.0;
//        float t;
//        vector[0] = (t = NumberTools.formCurvedFloat(seed += 0xCB72F6C7));
//        mag += t * t;
//        vector[1] = (t = NumberTools.formCurvedFloat(seed += 0xCB72F6C7));
//        mag += t * t;
//        vector[2] = (t = NumberTools.formCurvedFloat(seed += 0xCB72F6C7));
//        mag += t * t;
//        vector[3] = (t = NumberTools.formCurvedFloat(seed + 0xCB72F6C7));
//        mag += t * t;
//
//        if(mag == 0)
//        {
//            vector[0] = 1f;
//            mag = 1.0;
//        }
//        else
//            mag = Math.sqrt(mag);
//        vector[0] /= mag;
//        vector[1] /= mag;
//        vector[2] /= mag;
//        vector[3] /= mag;
//    }

//    static {
//        final float len = (float) (1.7861513777574233 / Math.sqrt(3.0));
//        for (int i = 0; i < 64; i++) {
////            float x = grad4f[i][0], y = grad4f[i][1], z = grad4f[i][2], w = grad4f[i][3];
////            final float len = 1.4142135623730951f / (float)Math.sqrt(x * x + y * y + z * z + w * w);
//            //final float len = 2f / Math.max(Math.abs(x), Math.max(Math.abs(y), Math.abs(z))), len3 = len * 1.5f;
//            grad4f[i][0] *= len;
//            grad4f[i][1] *= len;
//            grad4f[i][2] *= len;
//            grad4f[i][3] *= len;
//            System.out.println("{" + squidpony.StringKit.join(", ", grad4f[i]) + "},");
//        }
//    }

//    protected static final float[][] phiGrad3f = new float[96][3];
//
//    static {
//        final float root2 = 1.2599211f;
//        int i = 0;
//        for (; i < 16; i++) {
//            phiGrad3f[i][0] = phiGrad2f[i & 15][0] * root2;
//            phiGrad3f[i][1] = phiGrad2f[i & 15][1] * root2;
//        }
//        for (; i < 32; i++) {
//            phiGrad3f[i][0] = phiGrad2f[i & 15][1] * root2;
//            phiGrad3f[i][1] = phiGrad2f[i & 15][0] * root2;
//        }
//        for (; i < 48; i++) {
//            phiGrad3f[i][0] = phiGrad2f[i & 15][0] * root2;
//            phiGrad3f[i][2] = phiGrad2f[i & 15][1] * root2;
//        }
//        for (; i < 64; i++) {
//            phiGrad3f[i][0] = phiGrad2f[i & 15][1] * root2;
//            phiGrad3f[i][2] = phiGrad2f[i & 15][0] * root2;
//        }
//        for (; i < 80; i++) {
//            phiGrad3f[i][1] = phiGrad2f[i & 15][0] * root2;
//            phiGrad3f[i][2] = phiGrad2f[i & 15][1] * root2;
//        }
//        for (; i < 96; i++) {
//            phiGrad3f[i][1] = phiGrad2f[i & 15][1] * root2;
//            phiGrad3f[i][2] = phiGrad2f[i & 15][0] * root2;
//        }
//    }

//    public static final int[]
//            perm_x = {59, 146, 27, 99, 226, 210, 44, 129, 102, 237, 2, 107, 157, 173, 159, 16, 128, 41, 228, 114, 63, 105, 241, 144, 187, 116, 223, 122, 234, 52, 96, 35, 213, 176, 177, 141, 132, 240, 194, 163, 0, 3, 168, 133, 55, 203, 53, 50, 42, 79, 130, 156, 209, 135, 151, 178, 85, 154, 117, 148, 140, 82, 6, 69, 127, 214, 95, 175, 46, 30, 104, 197, 170, 33, 70, 167, 217, 233, 219, 84, 196, 109, 40, 190, 123, 165, 61, 212, 255, 184, 19, 182, 38, 112, 172, 103, 25, 244, 245, 201, 192, 60, 14, 231, 68, 71, 236, 193, 115, 7, 113, 118, 110, 131, 198, 216, 29, 195, 211, 246, 153, 222, 185, 208, 200, 158, 66, 137, 179, 26, 147, 235, 106, 90, 164, 9, 238, 101, 138, 227, 21, 37, 23, 152, 8, 161, 108, 250, 183, 225, 121, 24, 51, 252, 87, 242, 98, 188, 232, 171, 93, 56, 57, 5, 12, 120, 74, 43, 136, 139, 32, 13, 191, 67, 189, 186, 162, 199, 10, 20, 89, 15, 31, 58, 221, 18, 253, 28, 4, 218, 142, 205, 247, 94, 215, 39, 166, 150, 224, 77, 34, 169, 206, 47, 81, 97, 83, 220, 76, 229, 160, 54, 243, 45, 181, 92, 119, 48, 155, 62, 174, 248, 36, 239, 145, 124, 125, 65, 72, 180, 134, 111, 204, 207, 100, 73, 251, 143, 249, 254, 230, 11, 78, 80, 149, 75, 91, 126, 17, 86, 49, 88, 64, 22, 202, 1},
//            perm_y = {189, 111, 17, 214, 57, 208, 191, 225, 241, 152, 145, 71, 2, 141, 183, 218, 66, 178, 34, 161, 198, 47, 200, 180, 134, 239, 162, 18, 155, 216, 192, 173, 219, 9, 51, 124, 95, 122, 217, 135, 31, 50, 179, 237, 32, 39, 209, 112, 96, 92, 68, 79, 228, 193, 234, 90, 164, 137, 196, 184, 185, 114, 226, 67, 249, 163, 85, 26, 125, 28, 251, 45, 61, 220, 213, 139, 70, 201, 243, 22, 142, 246, 102, 229, 10, 107, 4, 240, 194, 35, 230, 86, 223, 20, 12, 233, 23, 77, 119, 176, 147, 182, 21, 195, 91, 118, 247, 33, 100, 99, 29, 188, 172, 144, 136, 131, 40, 13, 38, 150, 224, 205, 8, 252, 253, 190, 46, 143, 53, 231, 153, 94, 177, 88, 55, 105, 121, 16, 25, 207, 138, 5, 63, 82, 202, 58, 170, 41, 78, 167, 64, 60, 14, 103, 42, 154, 19, 80, 72, 37, 83, 129, 187, 244, 215, 242, 81, 15, 151, 186, 59, 101, 168, 175, 89, 248, 232, 212, 204, 199, 108, 73, 98, 210, 44, 1, 76, 48, 49, 250, 106, 203, 113, 43, 221, 146, 245, 148, 115, 165, 181, 84, 93, 3, 206, 65, 123, 158, 6, 126, 238, 109, 130, 227, 140, 120, 74, 171, 110, 222, 87, 156, 132, 97, 159, 197, 255, 56, 27, 62, 157, 75, 211, 254, 127, 169, 236, 235, 149, 52, 36, 24, 0, 11, 160, 133, 174, 30, 104, 69, 128, 116, 117, 54, 166, 7},
//            perm_z = {253, 212, 4, 237, 36, 182, 213, 233, 147, 239, 226, 41, 74, 65, 68, 165, 70, 231, 217, 116, 113, 193, 162, 112, 228, 254, 183, 176, 151, 80, 17, 60, 155, 246, 174, 3, 202, 208, 127, 7, 57, 1, 132, 79, 224, 99, 238, 195, 236, 9, 115, 154, 23, 227, 76, 158, 130, 16, 89, 214, 61, 114, 187, 90, 49, 24, 64, 33, 96, 242, 25, 37, 215, 35, 46, 109, 134, 141, 136, 225, 138, 43, 21, 184, 189, 13, 230, 188, 40, 50, 243, 244, 211, 156, 85, 120, 223, 58, 234, 71, 6, 28, 179, 67, 125, 69, 192, 131, 44, 175, 34, 15, 32, 77, 191, 222, 83, 47, 128, 218, 198, 84, 149, 26, 121, 190, 255, 150, 117, 92, 140, 101, 172, 62, 93, 97, 27, 103, 106, 161, 194, 201, 204, 45, 206, 111, 81, 252, 249, 73, 42, 248, 108, 118, 63, 56, 31, 216, 153, 180, 19, 126, 38, 139, 66, 88, 247, 143, 177, 137, 12, 199, 104, 235, 102, 75, 100, 129, 251, 18, 159, 107, 196, 22, 10, 152, 209, 94, 181, 250, 51, 210, 185, 144, 200, 169, 232, 122, 145, 173, 95, 171, 166, 229, 14, 5, 0, 105, 2, 163, 157, 48, 53, 133, 110, 52, 160, 186, 123, 124, 91, 20, 221, 240, 87, 178, 98, 207, 142, 148, 59, 203, 245, 205, 72, 11, 164, 39, 170, 135, 168, 197, 55, 86, 219, 167, 8, 82, 78, 220, 29, 146, 241, 54, 119, 30},
//            perm_w = {57, 1, 140, 48, 61, 156, 230, 173, 2, 231, 12, 214, 142, 242, 255, 195, 198, 220, 157, 139, 194, 99, 247, 248, 155, 178, 29, 41, 23, 193, 0, 30, 95, 171, 174, 222, 91, 54, 8, 67, 32, 129, 46, 124, 172, 148, 17, 105, 228, 118, 191, 33, 224, 5, 25, 158, 185, 92, 63, 199, 53, 107, 34, 180, 125, 69, 200, 116, 121, 216, 42, 233, 70, 43, 72, 26, 202, 62, 51, 15, 10, 16, 217, 207, 14, 175, 59, 52, 223, 246, 89, 109, 83, 13, 68, 90, 147, 239, 234, 18, 151, 114, 76, 143, 100, 197, 106, 176, 232, 208, 85, 165, 40, 186, 251, 101, 44, 65, 93, 218, 253, 144, 123, 11, 113, 167, 102, 240, 177, 137, 4, 184, 181, 20, 110, 37, 138, 111, 132, 94, 6, 122, 119, 75, 78, 84, 21, 3, 74, 235, 127, 112, 19, 58, 149, 161, 159, 73, 136, 150, 215, 35, 38, 86, 211, 190, 128, 203, 168, 9, 166, 244, 36, 28, 153, 225, 108, 254, 55, 169, 104, 141, 145, 22, 49, 212, 183, 79, 189, 227, 170, 60, 245, 205, 64, 252, 241, 80, 162, 97, 206, 163, 192, 146, 66, 182, 187, 135, 130, 152, 81, 71, 134, 39, 179, 188, 87, 126, 209, 229, 219, 133, 204, 210, 27, 103, 98, 154, 31, 250, 196, 7, 236, 77, 226, 56, 96, 88, 221, 45, 160, 50, 115, 237, 164, 201, 213, 82, 117, 24, 243, 131, 249, 47, 238, 120},
//            perm_u = {132, 148, 19, 244, 162, 163, 194, 37, 4, 250, 198, 154, 170, 137, 6, 60, 123, 73, 138, 41, 145, 92, 61, 82, 251, 175, 57, 207, 153, 50, 113, 105, 106, 242, 253, 94, 128, 9, 164, 143, 234, 80, 160, 252, 136, 239, 232, 150, 89, 167, 100, 131, 127, 178, 31, 188, 217, 5, 27, 33, 119, 152, 83, 195, 72, 88, 223, 176, 110, 111, 134, 233, 200, 190, 130, 86, 102, 69, 202, 240, 63, 13, 70, 229, 93, 24, 241, 22, 191, 99, 245, 139, 85, 254, 53, 45, 46, 182, 185, 26, 76, 197, 104, 67, 174, 20, 108, 184, 68, 171, 172, 90, 29, 107, 32, 79, 59, 126, 211, 112, 157, 201, 215, 237, 51, 84, 23, 135, 12, 28, 155, 124, 42, 43, 74, 173, 140, 114, 78, 18, 34, 1, 142, 180, 243, 193, 2, 161, 25, 212, 181, 218, 115, 39, 177, 71, 17, 186, 249, 225, 226, 122, 117, 214, 8, 129, 44, 7, 98, 216, 40, 116, 0, 103, 96, 30, 209, 47, 236, 11, 247, 58, 151, 52, 81, 141, 147, 169, 255, 16, 219, 75, 192, 208, 87, 56, 230, 231, 14, 97, 64, 54, 10, 222, 238, 205, 66, 120, 183, 133, 206, 109, 213, 144, 121, 158, 55, 235, 125, 3, 221, 118, 189, 165, 166, 62, 49, 146, 196, 77, 224, 203, 38, 156, 228, 48, 204, 35, 36, 210, 149, 227, 168, 199, 179, 246, 91, 248, 21, 65, 95, 101, 187, 220, 159, 15},
//            perm_v = {2, 9, 4, 237, 219, 73, 247, 203, 228, 220, 46, 229, 61, 156, 170, 75, 223, 144, 81, 252, 172, 208, 76, 218, 177, 103, 123, 244, 14, 39, 255, 90, 168, 43, 174, 3, 113, 107, 145, 233, 130, 254, 192, 11, 211, 190, 68, 105, 117, 178, 251, 18, 66, 242, 230, 248, 95, 137, 29, 26, 164, 65, 153, 120, 70, 77, 64, 33, 23, 133, 59, 7, 40, 16, 106, 41, 121, 216, 238, 135, 19, 212, 157, 48, 232, 28, 128, 22, 245, 171, 183, 56, 74, 99, 51, 150, 236, 111, 234, 71, 189, 167, 213, 37, 198, 50, 12, 79, 31, 250, 136, 165, 185, 246, 55, 86, 142, 62, 42, 52, 147, 205, 89, 94, 224, 141, 221, 180, 138, 129, 140, 101, 83, 193, 127, 67, 108, 84, 166, 109, 181, 20, 34, 195, 87, 24, 217, 116, 36, 88, 196, 82, 57, 239, 243, 124, 134, 175, 119, 210, 32, 163, 38, 139, 249, 227, 25, 97, 10, 118, 72, 131, 91, 54, 204, 225, 253, 58, 115, 154, 202, 122, 110, 112, 215, 1, 149, 146, 44, 201, 17, 240, 206, 197, 200, 169, 159, 13, 179, 143, 160, 152, 226, 161, 241, 80, 102, 15, 155, 92, 21, 184, 96, 148, 8, 158, 125, 35, 63, 176, 194, 235, 187, 30, 100, 231, 98, 207, 53, 47, 93, 173, 78, 186, 132, 199, 151, 114, 0, 45, 49, 126, 191, 222, 6, 182, 162, 188, 27, 69, 209, 214, 104, 5, 85, 60};

    protected static float dotf(final float g[], final float x, final float y) {
        return g[0] * x + g[1] * y;
    }

    protected static float dotf(final float g[], final float x, final float y, final float z) {
        return g[0] * x + g[1] * y + g[2] * z;
    }

//    protected static double dot(final float g[], final double x, final double y, final double z) {
//        return g[0] * x + g[1] * y + g[2] * z;
//    }
//    protected static double dot(final float g[], final double x, final double y, final double z, final double w) {
//        return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
//    }

    /**
     * Computes the hashing for an integer point and its dot product with a double point as one step.
     * This code is largely drawn from Jordan Peck's MIT-licensed code, https://github.com/Auburns/FastNoise_Java ,
     * present in SquidLib as {@link FastNoise}.
     * @param seed
     * @param x
     * @param y
     * @param z
     * @param xd
     * @param yd
     * @param zd
     * @return a double between -1.25 and 1.25, I think
     */
    protected static double gradCoord3D(long seed, int x, int y, int z, double xd, double yd, double zd) {
//        seed ^= 0xB4C4D * x ^ 0xEE2C1 * y ^ 0xA7E07 * z;
//        seed = seed * seed * seed * 60493L;
//        seed ^= (seed >>> 13);
//        final int hash = (int)(seed & 31) * 3;
        final int hash =
                ((int)(((seed ^= 0xB4C4D * x ^ 0xEE2C1 * y ^ 0xA7E07 * z) ^ seed >>> 13) * (seed & 0xFFFFF))
                       >>> 27) * 3;
        return xd * grad3d[hash] + yd * grad3d[hash + 1] + zd * grad3d[hash + 2];
    }
    
    /**
     * 2D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double)} and this method. Roughly
     * 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks because
     * it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good distribution
     * and is fast) instead of a number chosen by hash from a single 256-element array.
     *
     * @param x X input; works well if between 0.0 and 1.0, but anything is accepted
     * @param y Y input; works well if between 0.0 and 1.0, but anything is accepted
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoise(final double x, final double y) {
        return noise(x, y, seed);
    }

    /**
     * Identical to {@link #getNoise(double, double)}; ignores seed.
     * @param x X input; works well if between 0.0 and 1.0, but anything is accepted
     * @param y Y input; works well if between 0.0 and 1.0, but anything is accepted
     * @param seed ignored entirely.
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoiseWithSeed(final double x, final double y, final long seed) {
        return noise(x, y, seed);
    }
    /**
     * 3D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)} and this method.
     * Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks
     * because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good
     * distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoise(final double x, final double y, final double z) {
        return noise(x, y, z, seed);
    }
    /**
     * Identical to {@link #getNoise(double, double, double)}; ignores seed.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param seed ignored entirely.
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoiseWithSeed(final double x, final double y, final double z, final long seed) {
        return noise(x, y, z, seed);
    }

    /**
     * 4D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)} and this method.
     * Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks
     * because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good
     * distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param w W input (fourth-dimension)
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoise(final double x, final double y, final double z, final double w) {
        return noise(x, y, z, w, seed);
    }
    /**
     * Identical to {@link #getNoise(double, double, double, double)}; ignores seed.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param w W input (fourth-dimension)
     * @param seed ignored entirely.
     * @return noise from -1.0 to 1.0, inclusive
     */
    public double getNoiseWithSeed(final double x, final double y, final double z, final double w, final long seed) {
        return noise(x, y, z, w, seed);
    }


    /**
     * 2D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double)} and this method. Roughly
     * 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks because
     * it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good distribution
     * and is fast) instead of a number chosen by hash from a single 256-element array.
     *
     * @param xin X input; works well if between 0.0 and 1.0, but anything is accepted
     * @param yin Y input; works well if between 0.0 and 1.0, but anything is accepted
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double xin, final double yin){
        return noise(xin, yin, 123456789);
    }

    /**
     * 2D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double)} and this method. Roughly
     * 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks because
     * it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very good distribution
     * and is fast) instead of a number chosen by hash from a single 256-element array.
     *
     * @param xin X input; works well if between 0.0 and 1.0, but anything is accepted
     * @param yin Y input; works well if between 0.0 and 1.0, but anything is accepted
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double xin, final double yin, final long seed) {
        //xin *= epi;
        //yin *= epi;
        double noise0, noise1, noise2; // from the three corners
        // Skew the input space to figure out which simplex cell we're in
        double skew = (xin + yin) * F2; // Hairy factor for 2D
        int i = fastFloor(xin + skew);
        int j = fastFloor(yin + skew);
        double t = (i + j) * G2;
        double X0 = i - t; // Unskew the cell origin back to (x,y) space
        double Y0 = j - t;
        double x0 = xin - X0; // The x,y distances from the cell origin
        double y0 = yin - Y0;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // determine which simplex we are in.
        int i1, j1; // Offsets for second (middle) corner of simplex in (i,j)
        // coords
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        else {
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y),
        // where
        // c = (3-sqrt(3))/6
        double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y)
        // unskewed coords
        double y1 = y0 - j1 + G2;
        double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y)
        // unskewed coords
        double y2 = y0 - 1.0 + 2.0 * G2;
        // Work out the hashed gradient indices of the three simplex corners
        /*
        int ii = i & 255;
        int jj = j & 255;
        int gi0 = perm[ii + perm[jj]] & 15;
        int gi1 = perm[ii + i1 + perm[jj + j1]] & 15;
        int gi2 = perm[ii + 1 + perm[jj + 1]] & 15;
        */
        /*
        int hash = (int) rawNoise(i + (j * 0x9E3779B9),
                i + i1 + ((j + j1) * 0x9E3779B9),
                i + 1 + ((j + 1) * 0x9E3779B9),
                seed);
        int gi0 = hash & 15;
        int gi1 = (hash >>>= 4) & 15;
        int gi2 = (hash >>> 4) & 15;
        */
//        int gi0 = determine256(seed + i + determine(j));
//        int gi1 = determine256(seed + i + i1 + determine(j + j1));
//        int gi2 = determine256(seed + i + 1 + determine(j + 1));
        final int s0 = (int)(seed & 63), s1 = (int)(seed >>> 6 & 63);
        final int gi0 = perm_x[i + s0 & 255] ^ perm_y[j + s1 & 255];
        final int gi1 = perm_x[i + i1 + s0 & 255] ^ perm_y[j + j1 + s1 & 255];
        final int gi2 = perm_x[i + 1 + s0 & 255] ^ perm_y[j + 1 + s1 & 255];

        // Calculate the contribution from the three corners
        double t0 = 0.75 - x0 * x0 - y0 * y0;
        if (t0 < 0) {
            noise0 = 0.0;
        } else {
            t0 *= t0;
            noise0 = t0 * t0 * dot(phiGrad2[gi0], x0, y0);
            // for 2D gradient
        }
        double t1 = 0.75 - x1 * x1 - y1 * y1;
        if (t1 < 0) {
            noise1 = 0.0;
        } else {
            t1 *= t1;
            noise1 = t1 * t1 * dot(phiGrad2[gi1], x1, y1);
        }
        double t2 = 0.75 - x2 * x2 - y2 * y2;
        if (t2 < 0) {
            noise2 = 0.0;
        } else {
            t2 *= t2;
            noise2 = t2 * t2 * dot(phiGrad2[gi2], x2, y2);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return  9.125 * (noise0 + noise1 + noise2);
    }



    /**
     * 3D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)} and this method.
     * Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks
     * because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very
     * good distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param xin X input
     * @param yin Y input
     * @param zin Z input
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double xin, final double yin, final double zin){
        return noise(xin, yin, zin, 123456789);
    }

    /**
     * 3D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)} and this method.
     * Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in chunks
     * because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very
     * good distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param xin X input
     * @param yin Y input
     * @param zin Z input
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double xin, final double yin, final double zin, final long seed){
        double n = 0.0; // Noise contributions are added here
        // Skew the input space to figure out which simplex cell we're in
        double s = (xin + yin + zin) * F3; // Very nice and simple skew
        // factor for 3D
        int i = fastFloor(xin + s);
        int j = fastFloor(yin + s);
        int k = fastFloor(zin + s);
        double t = (i + j + k) * G3;
        double X0 = i - t; // Unskew the cell origin back to (x,y,z) space
        double Y0 = j - t;
        double Z0 = k - t;
        double x0 = xin - X0; // The x,y,z distances from the cell origin
        double y0 = yin - Y0;
        double z0 = zin - Z0;
        // For the 3D case, the simplex shape is a slightly irregular
        // tetrahedron.
        // determine which simplex we are in.
        int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
        int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
        if (x0 >= y0) {
            if (y0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // X Y Z order
            else if (x0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // X Z Y order
            else {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // Z X Y order
        } else { // x0<y0
            if (y0 < z0) {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Z Y X order
            else if (x0 < z0) {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Y Z X order
            else {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // Y X Z order
        }
        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in
        // (x,y,z),
        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in
        // (x,y,z), and
        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in
        // (x,y,z), where
        // c = 1/6.
        double x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
        double y1 = y0 - j1 + G3;
        double z1 = z0 - k1 + G3;
        double x2 = x0 - i2 + F3; // Offsets for third corner in (x,y,z) coords
        double y2 = y0 - j2 + F3;
        double z2 = z0 - k2 + F3;
        double x3 = x0 - 0.5; // Offsets for last corner in (x,y,z) coords
        double y3 = y0 - 0.5;
        double z3 = z0 - 0.5;

        // Work out the hashed gradient indices of the four simplex corners

        /*
        int ii = i & 255;
        int jj = j & 255;
        int kk = k & 255;

        int gi0 = perm[ii + perm[jj + perm[kk]]] % 12;
        int gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]] % 12;
        int gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]] % 12;
        int gi3 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]] % 12;
        */
//        int gi0 = determine32(seed + i + determine(j + determine(k)));
//        int gi1 = determine32(seed + i + i1 + determine(j + j1 + determine(k + k1)));
//        int gi2 = determine32(seed + i + i2 + determine(j + j2 + determine(k + k2)));
//        int gi3 = determine32(seed + i + 1 + determine(j + 1 + determine(k + 1)));


//        final int s0 = (int)(seed & 63), s1 = (int)(seed >>> 6 & 63), s2 = (int)(seed >>> 12 & 63);
//        final int gi0 = (perm_x[(i) + s0 & 255] ^ perm_y[(j) + s1 & 255]           ^ perm_z[(k) + s2 & 255]) & 31;
//        final int gi1 = (perm_x[(i + i1) + s0 & 255] ^ perm_y[(j + j1) + s1 & 255] ^ perm_z[(k + k1) + s2 & 255]) & 31;
//        final int gi2 = (perm_x[(i + i2) + s0 & 255] ^ perm_y[(j + j2) + s1 & 255] ^ perm_z[(k + k2) + s2 & 255]) & 31;
//        final int gi3 = (perm_x[(i + 1) + s0 & 255] ^ perm_y[(j + 1) + s1 & 255]   ^ perm_z[(k + 1) + s2  & 255]) & 31;

        /*
        int hash = (int) rawNoise(i + ((j + k * 0x632BE5AB) * 0x9E3779B9),
                i + i1 + ((j + j1 + (k + k1) * 0x632BE5AB) * 0x9E3779B9),
                i + i2 + ((j + j2 + (k + k2) * 0x632BE5AB) * 0x9E3779B9),
                i + 1 + ((j + 1 + ((k + 1) * 0x632BE5AB)) * 0x9E3779B9),
                seed);
        int gi0 = (hash >>>= 4) % 12;
        int gi1 = (hash >>>= 4) % 12;
        int gi2 = (hash >>>= 4) % 12;
        int gi3 = (hash >>> 4) % 12;
        */

        //int hash = (int) rawNoise(i, j, k, seed);
        //int gi0 = (hash >>>= 4) % 12, gi1 = (hash >>>= 4) % 12, gi2 = (hash >>>= 4) % 12, gi3 = (hash >>>= 4) % 12;
        // Calculate the contribution from the four corners
        double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
        if (t0 > 0) {
            t0 *= t0;
            n += t0 * t0 * gradCoord3D(seed, i, j, k, x0, y0, z0);
        }
        double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
        if (t1 > 0) {
            t1 *= t1;
            n += t1 * t1 * gradCoord3D(seed, i + i1, j + j1, k + k1, x1, y1, z1);
        }
        double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
        if (t2 > 0) {
            t2 *= t2;
            n += t2 * t2 * gradCoord3D(seed, i + i2, j + j2, k + k2, x2, y2, z2);
        }
        double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
        if (t3 > 0) {
            t3 *= t3;
            n += t3 * t3 * gradCoord3D(seed, i + 1, j + 1, k + 1, x3, y3, z3);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to stay just inside [-1,1]
        return 31.5 * n;

    }

    /**
     * 4D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double, double)} and this
     * method. Roughly 20-25% faster than the equivalent method in PerlinNoise, plus it has less chance of repetition in
     * chunks because it uses a pseudo-random function (curiously, {@link ThrustAltRNG#determine(long)}, which has very
     * good distribution and is fast) instead of a number chosen by hash from a single 256-element array.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param w W input (fourth-dimensional)
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double x, final double y, final double z, final double w) {
        return noise(x, y, z, w, 123456789);
    }

    /**
     * Used by {@link #noise(double, double, double, double, long)} to look up the vertices of the 4D triangle analogue.
     */
    protected static final int[] SIMPLEX = {0, 1, 3, 7, 0, 1, 7, 3,
            0, 0, 0, 0, 0, 3, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 1, 3, 7, 0, 0, 3, 1, 7, 0, 0, 0, 0,
            0, 7, 1, 3, 0, 7, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 1, 7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 7, 0, 0, 0, 0,
            1, 7, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            3, 7, 0, 1, 3, 7, 1, 0, 1, 0, 3, 7, 1, 0, 7, 3,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 1,
            0, 0, 0, 0, 3, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 7, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 1, 3, 7, 0, 3, 1,
            0, 0, 0, 0, 7, 1, 3, 0, 3, 1, 0, 7, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 0, 3, 0, 0, 0, 0,
            7, 3, 0, 1, 7, 3, 1, 0};

    /**
     * 4D simplex noise. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result will be
     * different when passing the same arguments to {@link PerlinNoise#noise(double, double, double, double)} and this
     * method. Roughly 20-25% faster than the equivalent method in PerlinNoise.
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @param w W input (fourth-dimensional)
     * @param seed any int; will be used to completely alter the noise
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static double noise(final double x, final double y, final double z, final double w, final long seed) {
        double n = 0.0;
        final double s = (x + y + z + w) * F4;
        final int i = fastFloor(x + s), j = fastFloor(y + s), k = fastFloor(z + s), l = fastFloor(w + s);
        final double[] gradient4DLUT = grad4;
        final double t = (i + j + k + l) * G4,
                X0 = i - t,
                Y0 = j - t,
                Z0 = k - t,
                W0 = l - t,
                x0 = x - X0,
                y0 = y - Y0,
                z0 = z - Z0,
                w0 = w - W0;
        final int c = (x0 > y0 ? 128 : 0) | (x0 > z0 ? 64 : 0) | (y0 > z0 ? 32 : 0) | (x0 > w0 ? 16 : 0) | (y0 > w0 ? 8 : 0) | (z0 > w0 ? 4 : 0);
        final int i1 = SIMPLEX[c] >>> 2,
                j1 = SIMPLEX[c | 1] >>> 2,
                k1 = SIMPLEX[c | 2] >>> 2,
                l1 = SIMPLEX[c | 3] >>> 2,
                i2 = SIMPLEX[c] >>> 1 & 1,
                j2 = SIMPLEX[c | 1] >>> 1 & 1,
                k2 = SIMPLEX[c | 2] >>> 1 & 1,
                l2 = SIMPLEX[c | 3] >>> 1 & 1,
                i3 = SIMPLEX[c] & 1,
                j3 = SIMPLEX[c | 1] & 1,
                k3 = SIMPLEX[c | 2] & 1,
                l3 = SIMPLEX[c | 3] & 1;
        final double x1 = x0 - i1 + G4,
                y1 = y0 - j1 + G4,
                z1 = z0 - k1 + G4,
                w1 = w0 - l1 + G4,
                x2 = x0 - i2 + 2 * G4,
                y2 = y0 - j2 + 2 * G4,
                z2 = z0 - k2 + 2 * G4,
                w2 = w0 - l2 + 2 * G4,
                x3 = x0 - i3 + 3 * G4,
                y3 = y0 - j3 + 3 * G4,
                z3 = z0 - k3 + 3 * G4,
                w3 = w0 - l3 + 3 * G4,
                x4 = x0 - 1 + 4 * G4,
                y4 = y0 - 1 + 4 * G4,
                z4 = z0 - 1 + 4 * G4,
                w4 = w0 - 1 + 4 * G4;
        final int s0 = (int)(seed & 63), s1 = (int)(seed >>> 6 & 63), s2 = (int)(seed >>> 12 & 63), s3 = (int)(seed >>> 18 & 63);
        final int h0 = (perm_x[(i) + s0 & 255] ^ perm_y[(j) + s1 & 255]           ^ perm_z[(k) + s2 & 255]      ^ perm_w[(l) + s3 & 255]) & 252;
        final int h1 = (perm_x[(i + i1) + s0 & 255] ^ perm_y[(j + j1) + s1 & 255] ^ perm_z[(k + k1) + s2 & 255] ^ perm_w[(l + l1) + s3 & 255]) & 252;
        final int h2 = (perm_x[(i + i2) + s0 & 255] ^ perm_y[(j + j2) + s1 & 255] ^ perm_z[(k + k2) + s2 & 255] ^ perm_w[(l + l2) + s3 & 255]) & 252;
        final int h3 = (perm_x[(i + i3) + s0 & 255] ^ perm_y[(j + j3) + s1 & 255] ^ perm_z[(k + k3) + s2 & 255] ^ perm_w[(l + l3) + s3 & 255]) & 252;
        final int h4 = (perm_x[(i + 1) + s0 & 255] ^ perm_y[(j + 1) + s1 & 255]   ^ perm_z[(k + 1) + s2  & 255] ^ perm_w[(l + 1) + s3 & 255]) & 252;
//        final int h0 = hash256_alt(i, j, k, l, seed) & 252;
//        final int h1 = hash256_alt(i + i1, j + j1, k + k1, l + l1, seed) & 252;
//        final int h2 = hash256_alt(i + i2, j + j2, k + k2, l + l2, seed) & 252;
//        final int h3 = hash256_alt(i + i3, j + j3, k + k3, l + l3, seed) & 252;
//        final int h4 = hash256_alt(i + 1, j + 1, k + 1, l + 1, seed) & 252;
        double t0 = 0.62 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
        if(t0 > 0) {
            t0 *= t0;
            n += t0 * t0 * (x0 * gradient4DLUT[h0] + y0 * gradient4DLUT[h0 | 1] + z0 * gradient4DLUT[h0 | 2] + w0 * gradient4DLUT[h0 | 3]);
        }
        double t1 = 0.62 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
        if (t1 > 0) {
            t1 *= t1;
            n += t1 * t1 * (x1 * gradient4DLUT[h1] + y1 * gradient4DLUT[h1 | 1] + z1 * gradient4DLUT[h1 | 2] + w1 * gradient4DLUT[h1 | 3]);
        }
        double t2 = 0.62 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
        if (t2 > 0) {
            t2 *= t2;
            n += t2 * t2 * (x2 * gradient4DLUT[h2] + y2 * gradient4DLUT[h2 | 1] + z2 * gradient4DLUT[h2 | 2] + w2 * gradient4DLUT[h2 | 3]);
        }
        double t3 = 0.62 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
        if (t3 > 0) {
            t3 *= t3;
            n += t3 * t3 * (x3 * gradient4DLUT[h3] + y3 * gradient4DLUT[h3 | 1] + z3 * gradient4DLUT[h3 | 2] + w3 * gradient4DLUT[h3 | 3]);
        }
        double t4 = 0.62 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
        if (t4 > 0) {
            t4 *= t4;
            n += t4 * t4 * (x4 * gradient4DLUT[h4] + y4 * gradient4DLUT[h4 | 1] + z4 * gradient4DLUT[h4 | 2] + w4 * gradient4DLUT[h4 | 3]);
        }
        //n *= 14.75;
        //if(n > 1.0 || n < -1.0) System.out.printf("x: %f, y: %f, z: %f, w: %f, n is %f\n", x, y, z, w, n);
        //return NumberTools.bounce(5.0 + 41.0 * n);
        return n * 14.75;//NumberTools.sway(0.5 + 12.75 * n);
    }


//    public static double noise(final double x, final double y, final double z, final double w, final long seed)
//    {
//        // The skewing and unskewing factors are hairy again for the 4D case
//
//        // Skew the (x,y,z,w) space to figure out which cell of 24 simplices
//        // we're in
//        double s = (x + y + z + w) * F4; // Factor for 4D skewing
//        int i = fastFloor(x + s);
//        int j = fastFloor(y + s);
//        int k = fastFloor(z + s);
//        int l = fastFloor(w + s);
//        double t = (i + j + k + l) * G4; // Factor for 4D unskewing
//        double X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
//        double Y0 = j - t;
//        double Z0 = k - t;
//        double W0 = l - t;
//        double x0 = x - X0; // The x,y,z,w distances from the cell origin
//        double y0 = y - Y0;
//        double z0 = z - Z0;
//        double w0 = w - W0;
//        // For the 4D case, the simplex is a 4D shape I won't even try to
//        // describe.
//        // To find out which of the 24 possible simplices we're in, we need
//        // to figure out the magnitude ordering of x0, y0, z0 and w0.
//        // The method below is a good way of finding the ordering of x,y,z,w
//        // and
//        // then find the correct traversal order for the simplex we’re in.
//        // First, six pair-wise comparisons are performed between each
//        // possible pair
//        // of the four coordinates, and the results are used to add up binary
//        // bits
//        // for an integer index.
//        int c = (x0 > y0 ? 32 : 0) | (x0 > z0 ? 16 : 0) | (y0 > z0 ? 8 : 0) |
//                (x0 > w0 ? 4 : 0) | (y0 > w0 ? 2 : 0) | (z0 > w0 ? 1 : 0);
//
//        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some
//        // order.
//        // Many values of c will never occur, since e.g. x>y>z>w makes x<z,
//        // y<w and x<w
//        // impossible. Only the 24 indices which have non-zero entries make
//        // any sense.
//        // We use a thresholding to set the coordinates in turn from the
//        // largest magnitude.
//        // The number 3 in the "simplex" array is at the position of the
//        // largest coordinate.
//
//        // The integer offsets for the second simplex corner
//        int i1 = simplex[c][0] >= 3 ? 1 : 0;
//        int j1 = simplex[c][1] >= 3 ? 1 : 0;
//        int k1 = simplex[c][2] >= 3 ? 1 : 0;
//        int l1 = simplex[c][3] >= 3 ? 1 : 0;
//        // The number 2 in the "simplex" array is at the second largest
//        // coordinate.
//
//        // The integer offsets for the third simplex corner
//        int i2 = simplex[c][0] >= 2 ? 1 : 0;
//        int j2 = simplex[c][1] >= 2 ? 1 : 0;
//        int k2 = simplex[c][2] >= 2 ? 1 : 0;
//        int l2 = simplex[c][3] >= 2 ? 1 : 0;
//        // The number 1 in the "simplex" array is at the second smallest
//        // coordinate.
//
//        // The integer offsets for the fourth simplex corner
//        int i3 = simplex[c][0] >= 1 ? 1 : 0;
//        int j3 = simplex[c][1] >= 1 ? 1 : 0;
//        int k3 = simplex[c][2] >= 1 ? 1 : 0;
//        int l3 = simplex[c][3] >= 1 ? 1 : 0;
//        // The fifth corner has all coordinate offsets = 1, so no need to
//        // look that up.
//        double x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
//        double y1 = y0 - j1 + G4;
//        double z1 = z0 - k1 + G4;
//        double w1 = w0 - l1 + G4;
//        double x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
//        double y2 = y0 - j2 + 2.0 * G4;
//        double z2 = z0 - k2 + 2.0 * G4;
//        double w2 = w0 - l2 + 2.0 * G4;
//        double x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
//        double y3 = y0 - j3 + 3.0 * G4;
//        double z3 = z0 - k3 + 3.0 * G4;
//        double w3 = w0 - l3 + 3.0 * G4;
//        double x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
//        double y4 = y0 - 1.0 + 4.0 * G4;
//        double z4 = z0 - 1.0 + 4.0 * G4;
//        double w4 = w0 - 1.0 + 4.0 * G4;
//
//        final int s0 = (int)(seed & 63), s1 = (int)(seed >>> 6 & 63), s2 = (int)(seed >>> 12 & 63), s3 = (int)(seed >>> 18 & 63);
//        final int gi0 = (perm_x[(i) + s0 & 255] ^ perm_y[(j) + s1 & 255]           ^ perm_z[(k) + s2 & 255]      ^ perm_w[(l) + s3 & 255]) & 63;
//        final int gi1 = (perm_x[(i + i1) + s0 & 255] ^ perm_y[(j + j1) + s1 & 255] ^ perm_z[(k + k1) + s2 & 255] ^ perm_w[(l + l1) + s3 & 255]) & 63;
//        final int gi2 = (perm_x[(i + i2) + s0 & 255] ^ perm_y[(j + j2) + s1 & 255] ^ perm_z[(k + k2) + s2 & 255] ^ perm_w[(l + l2) + s3 & 255]) & 63;
//        final int gi3 = (perm_x[(i + i3) + s0 & 255] ^ perm_y[(j + j3) + s1 & 255] ^ perm_z[(k + k3) + s2 & 255] ^ perm_w[(l + l3) + s3 & 255]) & 63;
//        final int gi4 = (perm_x[(i + 1) + s0 & 255] ^ perm_y[(j + 1) + s1 & 255]   ^ perm_z[(k + 1) + s2  & 255] ^ perm_w[(l + 1) + s3 & 255]) & 63;
//        // Noise contributions from the five corners are n0 to n4
//
//        // Calculate the contribution from the five corners
//        double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0, n0;
//        if (t0 < 0) {
//            n0 = 0.0;
//        } else {
//            t0 *= t0;
//            n0 = t0 * t0 * dot(grad4f[gi0], x0, y0, z0, w0);
//        }
//        double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1, n1;
//        if (t1 < 0) {
//            n1 = 0.0;
//        } else {
//            t1 *= t1;
//            n1 = t1 * t1 * dot(grad4f[gi1], x1, y1, z1, w1);
//        }
//        double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2,  n2;
//        if (t2 < 0) {
//            n2 = 0.0;
//        } else {
//            t2 *= t2;
//            n2 = t2 * t2 * dot(grad4f[gi2], x2, y2, z2, w2);
//        }
//        double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3, n3;
//        if (t3 < 0) {
//            n3 = 0.0;
//        } else {
//            t3 *= t3;
//            n3 = t3 * t3 * dot(grad4f[gi3], x3, y3, z3, w3);
//        }
//        double t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4, n4;
//        if (t4 < 0) {
//            n4 = 0.0;
//        } else {
//            t4 *= t4;
//            n4 = t4 * t4 * dot(grad4f[gi4], x4, y4, z4, w4);
//        }
//        // Sum up and scale the result to cover the range [-1,1]
//        return 17.0 * (n0 + n1 + n2 + n3 + n4);
//    }

    /**
     * 2D simplex noise returning a float; extremely similar to {@link #noise(double, double)}, but this may be slightly
     * faster or slightly slower. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of the result
     * will be different when passing the same arguments to {@link PerlinNoise#noise(double, double)} and this method.
     * This also cannot take a seed, while {@link #noise(double, double, long)} can.
     * @param x x input; works well if between 0.0 and 1.0, but anything is accepted
     * @param y y input; works well if between 0.0 and 1.0, but anything is accepted
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static float noiseAlt(double x, double y) {
        //xin *= epi;
        //yin *= epi;
        float noise0, noise1, noise2; // from the three corners
        float xin = (float)x, yin = (float)y;
        // Skew the input space to figure out which simplex cell we're in
        float skew = (xin + yin) * F2f; // Hairy factor for 2D
        int i = fastFloor(xin + skew);
        int j = fastFloor(yin + skew);
        float t = (i + j) * G2f;
        float X0 = i - t; // Unskew the cell origin back to (x,y) space
        float Y0 = j - t;
        float x0 = xin - X0; // The x,y distances from the cell origin
        float y0 = yin - Y0;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // determine which simplex we are in.
        int i1, j1; // Offsets for second (middle) corner of simplex in (i,j)
        // coords
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        else {
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y),
        // where: c = (3-sqrt(3))/6
        float x1 = x0 - i1 + G2f; // Offsets for middle corner in (x,y)
        // unskewed coords
        float y1 = y0 - j1 + G2f;
        float x2 = x0 - 1f + 2f * G2f; // Offsets for last corner in (x,y)
        // unskewed coords
        float y2 = y0 - 1f + 2f * G2f;
        // Work out the hashed gradient indices of the three simplex corners
//        int gi0 = determine256(i + determine(j));
//        int gi1 = determine256(i + i1 + determine(j + j1));
//        int gi2 = determine256(i + 1 + determine(j + 1));
        final int gi0 = perm_x[i & 255] ^ perm_y[j & 255];
        final int gi1 = perm_x[i + i1 & 255] ^ perm_y[j + j1 & 255];
        final int gi2 = perm_x[i + 1 & 255] ^ perm_y[j + 1 & 255];

        // Calculate the contribution from the three corners
        float t0 = 0.75f - x0 * x0 - y0 * y0;
        if (t0 < 0) {
            noise0 = 0.0f;
        } else {
            t0 *= t0;
            noise0 = t0 * t0 * dotf(phiGrad2f[gi0], x0, y0);
            // for 2D gradient
        }
        float t1 = 0.75f - x1 * x1 - y1 * y1;
        if (t1 < 0) {
            noise1 = 0.0f;
        } else {
            t1 *= t1;
            noise1 = t1 * t1 * dotf(phiGrad2f[gi1], x1, y1);
        }
        float t2 = 0.75f - x2 * x2 - y2 * y2;
        if (t2 < 0) {
            noise2 = 0.0f;
        } else {
            t2 *= t2;
            noise2 = t2 * t2 * dotf(phiGrad2f[gi2], x2, y2);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return 9.125f * (noise0 + noise1 + noise2);
    }

    /**
     * 3D simplex noise returning a float; extremely similar to {@link #noise(double, double, double)}, but this may
     * be slightly faster or slightly slower. Unlike {@link PerlinNoise}, uses its parameters verbatim, so the scale of
     * the result will be different when passing the same arguments to {@link PerlinNoise#noise(double, double, double)}
     * and this method. This also cannot take a seed, while {@link #noise(double, double, double, long)} can.
     *
     * @param x X input
     * @param y Y input
     * @param z Z input
     * @return noise from -1.0 to 1.0, inclusive
     */
    public static float noiseAlt(double x, double y, double z) {
        //xin *= epi;
        //yin *= epi;
        //zin *= epi;
        float xin = (float)x, yin = (float)y, zin = (float)z;
        float n0, n1, n2, n3; // Noise contributions from the four corners
        // Skew the input space to figure out which simplex cell we're in
        float s = (xin + yin + zin) * F3f; // Very nice and simple skew
        // factor for 3D
        int i = fastFloor(xin + s);
        int j = fastFloor(yin + s);
        int k = fastFloor(zin + s);
        float t = (i + j + k) * G3f;
        float X0 = i - t; // Unskew the cell origin back to (x,y,z) space
        float Y0 = j - t;
        float Z0 = k - t;
        float x0 = xin - X0; // The x,y,z distances from the cell origin
        float y0 = yin - Y0;
        float z0 = zin - Z0;
        // For the 3D case, the simplex shape is a slightly irregular
        // tetrahedron.
        // determine which simplex we are in.
        int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k)
        // coords
        int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k)
        // coords
        if (x0 >= y0) {
            if (y0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // X Y Z order
            else if (x0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // X Z Y order
            else {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // Z X Y order
        } else { // x0<y0
            if (y0 < z0) {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Z Y X order
            else if (x0 < z0) {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Y Z X order
            else {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // Y X Z order
        }
        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in
        // (x,y,z),
        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in
        // (x,y,z), and
        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in
        // (x,y,z), where
        // c = 1/6.
        float x1 = x0 - i1 + G3f; // Offsets for second corner in (x,y,z)
        // coords
        float y1 = y0 - j1 + G3f;
        float z1 = z0 - k1 + G3f;
        float x2 = x0 - i2 + F3f; // Offsets for third corner in
        // (x,y,z) coords
        float y2 = y0 - j2 + F3f;
        float z2 = z0 - k2 + F3f;
        float x3 = x0 - 0.5f; // Offsets for last corner in
        // (x,y,z) coords
        float y3 = y0 - 0.5f;
        float z3 = z0 - 0.5f;
        // Work out the hashed gradient indices of the four simplex corners

        /*
        int ii = i & 255;
        int jj = j & 255;
        int kk = k & 255;

        int gi0 = perm[ii + perm[jj + perm[kk]]] % 12;
        int gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]] % 12;
        int gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]] % 12;
        int gi3 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]] % 12;
        */
//        int gi0 = determine32(i + determine(j + determine(k)));
//        int gi1 = determine32(i + i1 + determine(j + j1 + determine(k + k1)));
//        int gi2 = determine32(i + i2 + determine(j + j2 + determine(k + k2)));
//        int gi3 = determine32(i + 1 + determine(j + 1 + determine(k + 1)));
        final int gi0 = (perm_x[(i) & 255] ^ perm_y[(j) & 255]           ^ perm_z[(k) + 67 & 255]) & 31;
        final int gi1 = (perm_x[(i + i1) & 255] ^ perm_y[(j + j1) & 255] ^ perm_z[(k + k1) + 67 & 255]) & 31;
        final int gi2 = (perm_x[(i + i2) & 255] ^ perm_y[(j + j2) & 255] ^ perm_z[(k + k2) + 67 & 255]) & 31;
        final int gi3 = (perm_x[(i + 1) & 255] ^ perm_y[(j + 1) & 255]   ^ perm_z[(k + 1) + 67  & 255]) & 31;


//        int gi0 = determineBounded(i + determine(j + determine(k)), 92);
//        int gi1 = determineBounded(i + i1 + determine(j + j1 + determine(k + k1)), 92);
//        int gi2 = determineBounded(i + i2 + determine(j + j2 + determine(k + k2)), 92);
//        int gi3 = determineBounded(i + 1 + determine(j + 1 + determine(k + 1)), 92);

        /*
        int hash = (int) rawNoise(i + ((j + k * 0x632BE5AB) * 0x9E3779B9),
                i + i1 + ((j + j1 + (k + k1) * 0x632BE5AB) * 0x9E3779B9),
                i + i2 + ((j + j2 + (k + k2) * 0x632BE5AB) * 0x9E3779B9),
                i + 1 + ((j + 1 + ((k + 1) * 0x632BE5AB)) * 0x9E3779B9),
                seed);
        int gi0 = (hash >>>= 4) % 12;
        int gi1 = (hash >>>= 4) % 12;
        int gi2 = (hash >>>= 4) % 12;
        int gi3 = (hash >>> 4) % 12;
        */

        //int hash = (int) rawNoise(i, j, k, seed);
        //int gi0 = (hash >>>= 4) % 12, gi1 = (hash >>>= 4) % 12, gi2 = (hash >>>= 4) % 12, gi3 = (hash >>>= 4) % 12;
        // Calculate the contribution from the four corners
        float t0 = 0.6f - x0 * x0 - y0 * y0 - z0 * z0;
        if (t0 < 0) {
            n0 = 0f;
        } else {
            t0 *= t0;
            n0 = t0 * t0 * dotf(grad3f[gi0], x0, y0, z0);
        }
        float t1 = 0.6f - x1 * x1 - y1 * y1 - z1 * z1;
        if (t1 < 0) {
            n1 = 0f;
        } else {
            t1 *= t1;
            n1 = t1 * t1 * dotf(grad3f[gi1], x1, y1, z1);
        }
        float t2 = 0.6f - x2 * x2 - y2 * y2 - z2 * z2;
        if (t2 < 0) {
            n2 = 0f;
        } else {
            t2 *= t2;
            n2 = t2 * t2 * dotf(grad3f[gi2], x2, y2, z2);
        }
        float t3 = 0.6f - x3 * x3 - y3 * y3 - z3 * z3;
        if (t3 < 0) {
            n3 = 0f;
        } else {
            t3 *= t3;
            n3 = t3 * t3 * dotf(grad3f[gi3], x3, y3, z3);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to stay just inside [-1,1]
        return  31.5f * (n0 + n1 + n2 + n3);
    }

}
